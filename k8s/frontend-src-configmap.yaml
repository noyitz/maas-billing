apiVersion: v1
kind: ConfigMap
metadata:
  name: maas-frontend-src
  namespace: llm
data:
  package.json: |
    {
      "name": "@maas/frontend",
      "version": "1.0.0",
      "private": true,
      "dependencies": {
        "@emotion/react": "^11.11.1",
        "@emotion/styled": "^11.11.0",
        "@mui/icons-material": "^5.14.16",
        "@mui/material": "^5.14.17",
        "@testing-library/jest-dom": "^5.17.0",
        "@testing-library/react": "^13.4.0",
        "@testing-library/user-event": "^13.5.0",
        "@types/jest": "^27.5.2",
        "@types/node": "^16.18.59",
        "@types/react": "^18.2.37",
        "@types/react-dom": "^18.2.15",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-scripts": "5.0.1",
        "typescript": "^4.9.5",
        "web-vitals": "^2.1.4"
      },
      "scripts": {
        "start": "react-scripts start",
        "build": "react-scripts build",
        "test": "react-scripts test",
        "eject": "react-scripts eject"
      },
      "eslintConfig": {
        "extends": [
          "react-app",
          "react-app/jest"
        ]
      },
      "browserslist": {
        "production": [
          ">0.2%",
          "not dead",
          "not op_mini all"
        ],
        "development": [
          "last 1 chrome version",
          "last 1 firefox version",
          "last 1 safari version"
        ]
      }
    }
  tsconfig.json: |
    {
      "compilerOptions": {
        "target": "es5",
        "lib": [
          "dom",
          "dom.iterable",
          "es6"
        ],
        "allowJs": true,
        "skipLibCheck": true,
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "strict": true,
        "forceConsistentCasingInFileNames": true,
        "noFallthroughCasesInSwitch": true,
        "module": "esnext",
        "moduleResolution": "node",
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx"
      },
      "include": [
        "src"
      ]
    }
  index.html: |
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="theme-color" content="#000000" />
        <meta name="description" content="MaaS Dashboard for Policy Management" />
        <title>MaaS Dashboard</title>
      </head>
      <body>
        <noscript>You need to enable JavaScript to run this app.</noscript>
        <div id="root"></div>
      </body>
    </html>
  index.tsx: |
    import React from 'react';
    import ReactDOM from 'react-dom/client';
    import './index.css';
    import App from './App';

    const root = ReactDOM.createRoot(
      document.getElementById('root') as HTMLElement
    );
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  index.css: |
    @tailwind base;
    @tailwind components;
    @tailwind utilities;

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
        'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
        sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    code {
      font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
        monospace;
    }
  App.css: |
    .App {
      text-align: center;
    }

    .App-logo {
      height: 40vmin;
      pointer-events: none;
    }

    @media (prefers-reduced-motion: no-preference) {
      .App-logo {
        animation: App-logo-spin infinite 20s linear;
      }
    }

    .App-header {
      background-color: #282c34;
      padding: 20px;
      color: white;
    }

    .App-link {
      color: #61dafb;
    }

    @keyframes App-logo-spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
  ThemeContext.tsx: |
    import React, { createContext, useContext, useState, useEffect } from 'react';
    import { createTheme, ThemeProvider as MuiThemeProvider } from '@mui/material/styles';
    import { CssBaseline } from '@mui/material';

    type ThemeMode = 'light' | 'dark';

    interface ThemeContextType {
      mode: ThemeMode;
      toggleTheme: () => void;
    }

    const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

    export const useTheme = () => {
      const context = useContext(ThemeContext);
      if (!context) {
        throw new Error('useTheme must be used within a ThemeProvider');
      }
      return context;
    };

    interface ThemeProviderProps {
      children: React.ReactNode;
    }

    export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
      const [mode, setMode] = useState<ThemeMode>(() => {
        // Get saved theme from localStorage or default to dark
        const savedMode = localStorage.getItem('themeMode') as ThemeMode;
        return savedMode || 'dark';
      });

      useEffect(() => {
        // Save theme preference to localStorage
        localStorage.setItem('themeMode', mode);
      }, [mode]);

      const toggleTheme = () => {
        setMode(prevMode => prevMode === 'light' ? 'dark' : 'light');
      };

      const theme = createTheme({
        palette: {
          mode,
          ...(mode === 'dark' ? {
            // Dark theme colors
            primary: {
              main: '#ee0000', // Red Hat red
              contrastText: '#ffffff',
            },
            secondary: {
              main: '#92107e', // Red Hat purple
              contrastText: '#ffffff',
            },
            background: {
              default: '#0f1419',
              paper: '#1c2128',
            },
            text: {
              primary: '#ffffff',
              secondary: '#b1b3b6',
            },
          } : {
            // Light theme colors
            primary: {
              main: '#ee0000', // Red Hat red
              contrastText: '#ffffff',
            },
            secondary: {
              main: '#92107e', // Red Hat purple
              contrastText: '#ffffff',
            },
            background: {
              default: '#ffffff',
              paper: '#f5f5f5',
            },
            text: {
              primary: '#333333',
              secondary: '#666666',
            },
          }),
        },
        typography: {
          fontFamily: '"Red Hat Display", "Roboto", "Helvetica", "Arial", sans-serif',
          h1: {
            fontWeight: 700,
          },
          h2: {
            fontWeight: 600,
          },
          h3: {
            fontWeight: 600,
          },
          h4: {
            fontWeight: 600,
          },
          h5: {
            fontWeight: 500,
          },
          h6: {
            fontWeight: 500,
          },
        },
        components: {
          MuiCard: {
            styleOverrides: {
              root: {
                borderRadius: 8,
                boxShadow: mode === 'dark' 
                  ? '0 2px 8px rgba(0, 0, 0, 0.3)'
                  : '0 2px 8px rgba(0, 0, 0, 0.1)',
              },
            },
          },
          MuiButton: {
            styleOverrides: {
              root: {
                borderRadius: 6,
                textTransform: 'none',
                fontWeight: 500,
              },
            },
          },
          MuiChip: {
            styleOverrides: {
              root: {
                borderRadius: 16,
              },
            },
          },
        },
      });

      const value = {
        mode,
        toggleTheme,
      };

      return (
        <ThemeContext.Provider value={value}>
          <MuiThemeProvider theme={theme}>
            <CssBaseline />
            {children}
          </MuiThemeProvider>
        </ThemeContext.Provider>
      );
    };
  useApi.ts: |
    import { useState, useEffect, useCallback } from 'react';
    import apiService from '../services/api';

    export const useModels = () => {
      const [models, setModels] = useState<any[]>([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);

      const fetchModels = useCallback(async () => {
        try {
          setLoading(true);
          setError(null);
          const data = await apiService.getModels();
          setModels(data);
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to fetch models');
        } finally {
          setLoading(false);
        }
      }, []);

      useEffect(() => {
        fetchModels();
      }, [fetchModels]);

      return { models, loading, error, refetch: fetchModels };
    };

    export const useLiveRequests = (autoRefresh: boolean = true, refreshInterval: number = 10000) => {
      const [requests, setRequests] = useState<any[]>([]);
      const [loading, setLoading] = useState(true);
      const [refreshing, setRefreshing] = useState(false);
      const [error, setError] = useState<string | null>(null);
      const [lastUpdated, setLastUpdated] = useState<Date | null>(null);

      const fetchLiveRequests = useCallback(async (isRefresh: boolean = false) => {
        try {
          if (isRefresh) {
            setRefreshing(true);
          }
          setError(null);
          const data = await apiService.getLiveRequests();
          setRequests(prev => {
            // Create a Map to track unique requests by ID
            const existingIds = new Set(prev.map((req: any) => req.id));
            
            // Only add new requests that don't already exist
            const newRequests = data.filter((req: any) => !existingIds.has(req.id));
            
            // Prepend new requests and keep last 100
            return [...newRequests, ...prev].slice(0, 100);
          });
          setLastUpdated(new Date());
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to fetch live requests');
        } finally {
          setLoading(false);
          if (isRefresh) {
            setRefreshing(false);
          }
        }
      }, []);

      useEffect(() => {
        fetchLiveRequests();
      }, [fetchLiveRequests]);

      useEffect(() => {
        if (!autoRefresh) return;

        const interval = setInterval(() => {
          fetchLiveRequests(true);
        }, refreshInterval);

        return () => clearInterval(interval);
      }, [autoRefresh, refreshInterval, fetchLiveRequests]);

      return { 
        requests, 
        loading, 
        refreshing, 
        error, 
        lastUpdated, 
        refetch: () => fetchLiveRequests(true) 
      };
    };

    export const useDashboardStats = (autoRefresh: boolean = true, refreshInterval: number = 15000) => {
      const [stats, setStats] = useState<any>(null);
      const [loading, setLoading] = useState(true);
      const [refreshing, setRefreshing] = useState(false);
      const [error, setError] = useState<string | null>(null);
      const [lastUpdated, setLastUpdated] = useState<Date | null>(null);

      const fetchStats = useCallback(async (isRefresh: boolean = false) => {
        try {
          if (isRefresh) {
            setRefreshing(true);
          } else {
            setLoading(true);
          }
          setError(null);
          const data = await apiService.getDashboardStats();
          setStats(data);
          setLastUpdated(new Date());
        } catch (err) {
          console.error('Dashboard stats error:', err);
          setError(err instanceof Error ? err.message : 'Failed to fetch dashboard stats');
        } finally {
          setLoading(false);
          if (isRefresh) {
            setRefreshing(false);
          }
        }
      }, []);

      useEffect(() => {
        fetchStats();
      }, [fetchStats]);

      useEffect(() => {
        if (!autoRefresh) return;

        const interval = setInterval(() => {
          fetchStats(true);
        }, refreshInterval);

        return () => clearInterval(interval);
      }, [autoRefresh, refreshInterval, fetchStats]);

      return { 
        stats, 
        loading, 
        refreshing, 
        error, 
        lastUpdated,
        refetch: () => fetchStats(true) 
      };
    };
  api.ts: |
    import config from '../config/environment';

    const API_BASE_URL = config.API_BASE_URL;

    interface SimulateRequestParams {
      model: string;
      messages: Array<{role: string, content: string}>;
      max_tokens?: number;
      tier: string;
      apiKey: string;
    }

    class ApiService {
      private async fetch(endpoint: string, options: RequestInit = {}) {
        const url = `${API_BASE_URL}${endpoint}`;
        const response = await fetch(url, {
          headers: {
            'Content-Type': 'application/json',
            ...options.headers,
          },
          ...options,
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data.success ? data.data : data;
      }

      async getModels() {
        return this.fetch('/models');
      }

      async getLiveRequests() {
        return this.fetch('/metrics/live-requests');
      }

      async getDashboardStats() {
        return this.fetch('/metrics/dashboard');
      }

      async getMetrics(timeRange: string = '1h') {
        return this.fetch(`/metrics?timeRange=${timeRange}`);
      }

      async getPolicies() {
        return this.fetch('/policies');
      }

      async createPolicy(policy: any) {
        return this.fetch('/policies', {
          method: 'POST',
          body: JSON.stringify(policy),
        });
      }

      async updatePolicy(id: string, policy: any) {
        return this.fetch(`/policies/${id}`, {
          method: 'PUT',
          body: JSON.stringify(policy),
        });
      }

      async deletePolicy(id: string) {
        return this.fetch(`/policies/${id}`, {
          method: 'DELETE',
        });
      }

      async getRequestDetails(id: string) {
        return this.fetch(`/metrics/requests/${id}`);
      }

      async getPolicyStats() {
        return this.fetch('/metrics/policy-stats');
      }

      async simulateRequest(params: SimulateRequestParams) {
        return this.fetch('/simulator/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${params.apiKey}`,
          },
          body: JSON.stringify({
            model: params.model,
            messages: params.messages,
            max_tokens: params.max_tokens || 100,
            tier: params.tier
          }),
        });
      }
    }

    const apiService = new ApiService();
    export default apiService;
  environment.ts: |
    // Environment configuration for the entire application
    export const config = {
      // Backend API base URL
      API_BASE_URL: process.env.REACT_APP_API_BASE_URL || '/api/v1',
      
      // Model serving configuration
      MODEL_SERVING: {
        // Deployment mode: 'kuadrant' for local Kuadrant with Host headers, 'direct' for direct endpoints
        mode: process.env.REACT_APP_MODEL_MODE || 'kuadrant',
        
        // Base URL for model requests (Kuadrant gateway or direct endpoints)
        baseUrl: process.env.REACT_APP_MODEL_BASE_URL || 'http://localhost:8080',
        
        // Host headers for Kuadrant domain-based routing
        hosts: {
          simulator: process.env.REACT_APP_SIMULATOR_HOST || 'simulator.maas.local',
          qwen3: process.env.REACT_APP_QWEN3_HOST || 'qwen3.maas.local',
        },
        
        // Model names
        models: {
          simulator: process.env.REACT_APP_SIMULATOR_MODEL || 'simulator-model',
          qwen3: process.env.REACT_APP_QWEN3_MODEL || 'qwen3-0-6b-instruct',
        }
      },
      
      // OpenAI API path
      OPENAI_CHAT_COMPLETIONS_PATH: '/v1/chat/completions',
      
      // Default tier-based API keys (in real deployment these would come from environment)
      API_KEYS: {
        free: process.env.REACT_APP_FREE_API_KEY || 'freeuser1_key',
        premium: process.env.REACT_APP_PREMIUM_API_KEY || 'premiumuser1_key',
        none: process.env.REACT_APP_NONE_API_KEY || '', // Empty key to test auth failures
      }
    };

    export default config;
  App.tsx: |
    import React, { useState } from 'react';
    import {
      AppBar,
      Box,
      Drawer,
      IconButton,
      List,
      ListItem,
      ListItemButton,
      ListItemIcon,
      ListItemText,
      Menu,
      MenuItem,
      Toolbar,
      Typography,
      Avatar,
    } from '@mui/material';
    import {
      Policy as PolicyIcon,
      BarChart as MetricsIcon,
      PlayArrow as SimulatorIcon,
      AccountCircle,
      Settings,
      Logout,
      LightMode,
      DarkMode,
    } from '@mui/icons-material';

    // Explicit imports to avoid bundling issues
    import PolicyManager from './components/PolicyManager';
    import MetricsDashboard from './components/MetricsDashboard';
    import RequestSimulator from './components/RequestSimulator';
    import { ThemeProvider, useTheme } from './contexts/ThemeContext';

    // Cache bust: force new bundle generation
    const BUILD_VERSION = '1.0.3';

    const drawerWidth = 240;

    function AppContent() {
      const [selectedView, setSelectedView] = useState('policies');
      const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
      const { mode, toggleTheme } = useTheme();

      const handleMenu = (event: React.MouseEvent<HTMLElement>) => {
        setAnchorEl(event.currentTarget);
      };

      const handleClose = () => {
        setAnchorEl(null);
      };

      const renderContent = () => {
        switch (selectedView) {
          case 'policies':
            return <PolicyManager />;
          case 'metrics':
            return <MetricsDashboard />;
          case 'simulator':
            return <RequestSimulator />;
          default:
            return <PolicyManager />;
        }
      };

      const menuItems = [
        { id: 'policies', label: 'Policy Manager', icon: <PolicyIcon /> },
        { id: 'metrics', label: 'Live Metrics', icon: <MetricsIcon /> },
        { id: 'simulator', label: 'Request Simulator', icon: <SimulatorIcon /> },
      ];

      return (
        <Box sx={{ display: 'flex' }}>      
          {/* App Bar */}
          <AppBar
            position="fixed"
            sx={{
              width: '100%',
              zIndex: (theme) => theme.zIndex.drawer + 1,
              backgroundColor: '#151515',
              borderBottom: '1px solid #333',
            }}
          >
            <Toolbar sx={{ minHeight: '64px !important' }}>
              {/* Logo and Title */}
              <Typography variant="h6" component="div" sx={{ color: 'white', mr: 2 }}>
                |
              </Typography>
              <Typography variant="h6" component="div" sx={{ color: 'white', fontWeight: 600 }}>
                MaaS
              </Typography>
              <Typography variant="body2" component="div" sx={{ color: '#999', ml: 1 }}>
                Inference Model as a Service
              </Typography>
              
              <Box sx={{ flexGrow: 1 }} />
              
              {/* Theme Toggle */}
              <IconButton
                color="inherit"
                onClick={toggleTheme}
                sx={{ mr: 2 }}
              >
                {mode === 'dark' ? <LightMode /> : <DarkMode />}
              </IconButton>
              
              <div>
                <IconButton
                  size="large"
                  aria-label="account of current user"
                  aria-controls="menu-appbar"
                  aria-haspopup="true"
                  onClick={handleMenu}
                  color="inherit"
                >
                  <Avatar sx={{ width: 32, height: 32, bgcolor: 'primary.main' }}>
                    U
                  </Avatar>
                </IconButton>
                <Menu
                  id="menu-appbar"
                  anchorEl={anchorEl}
                  anchorOrigin={{
                    vertical: 'top',
                    horizontal: 'right',
                  }}
                  keepMounted
                  transformOrigin={{
                    vertical: 'top',
                    horizontal: 'right',
                  }}
                  open={Boolean(anchorEl)}
                  onClose={handleClose}
                >
                  <MenuItem onClick={handleClose}>
                    <ListItemIcon>
                      <AccountCircle fontSize="small" />
                    </ListItemIcon>
                    Profile
                  </MenuItem>
                  <MenuItem onClick={() => { toggleTheme(); handleClose(); }}>
                    <ListItemIcon>
                      {mode === 'dark' ? <LightMode fontSize="small" /> : <DarkMode fontSize="small" />}
                    </ListItemIcon>
                    Switch to {mode === 'dark' ? 'Light' : 'Dark'} Mode
                  </MenuItem>
                  <MenuItem onClick={handleClose}>
                    <ListItemIcon>
                      <Settings fontSize="small" />
                    </ListItemIcon>
                    Settings
                  </MenuItem>
                  <MenuItem onClick={handleClose}>
                    <ListItemIcon>
                      <Logout fontSize="small" />
                    </ListItemIcon>
                    Logout
                  </MenuItem>
                </Menu>
              </div>
            </Toolbar>
          </AppBar>

          {/* Sidebar Drawer */}
          <Drawer
            sx={{
              width: drawerWidth,
              flexShrink: 0,
              '& .MuiDrawer-paper': {
                width: drawerWidth,
                boxSizing: 'border-box',
                backgroundColor: '#1a1a1a',
                borderRight: '1px solid #333',
              },
            }}
            variant="permanent"
            anchor="left"
          >
            {/* Navigation List */}
            <List sx={{ mt: 8 }}>
              {menuItems.map((item) => (
                <ListItem key={item.id} disablePadding>
                  <ListItemButton
                    selected={selectedView === item.id}
                    onClick={() => setSelectedView(item.id)}
                    sx={{
                      mx: 1,
                      mb: 0.5,
                      borderRadius: 1,
                      '&.Mui-selected': {
                        backgroundColor: '#ee0000',
                        '&:hover': {
                          backgroundColor: '#cc0000',
                        },
                      },
                      '&:hover': {
                        backgroundColor: '#333',
                      },
                    }}
                  >
                    <ListItemIcon sx={{ color: selectedView === item.id ? 'white' : '#999' }}>
                      {item.icon}
                    </ListItemIcon>
                    <ListItemText 
                      primary={item.label}
                      sx={{ 
                        '& .MuiListItemText-primary': {
                          color: selectedView === item.id ? 'white' : '#999',
                          fontWeight: selectedView === item.id ? 600 : 400,
                        }
                      }}
                    />
                  </ListItemButton>
                </ListItem>
              ))}
            </List>
          </Drawer>

          {/* Main content */}
          <Box
            component="main"
            sx={{
              flexGrow: 1,
              bgcolor: 'background.default',
              p: 3,
              width: `calc(100% - ${drawerWidth}px)`,
            }}
          >
            <Toolbar />
            {renderContent()}
          </Box>
        </Box>
      );
    }

    function App() {
      return (
        <ThemeProvider>
          <AppContent />
        </ThemeProvider>
      );
    }

    export default App;
  RequestSimulator.tsx: |
    import React, { useState, useEffect } from 'react';
    import {
      Box,
      Button,
      Card,
      CardContent,
      Grid,
      TextField,
      Typography,
      Alert,
      CircularProgress,
      Paper,
      Stack,
      Collapse,
      IconButton,
      Chip,
      Divider,
      AccordionSummary,
      AccordionDetails,
      Accordion,
    } from '@mui/material';
    import {
      PlayArrow as PlayIcon,
      SmartToy as ModelIcon,
      Group as TierIcon,
      CheckCircle as SuccessIcon,
      Error as ErrorIcon,
      Warning as WarningIcon,
      ExpandMore as ExpandMoreIcon,
      AccessTime as TimeIcon,
      Security as SecurityIcon,
    } from '@mui/icons-material';

    import { useTheme } from '../contexts/ThemeContext';
    import apiService from '../services/api';

    interface Model {
      id: string;
      name: string;
      endpoint: string;
      description: string;
    }

    interface Tier {
      id: string;
      name: string;
      description: string;
      apiKey: string;
      limits: string;
    }

    interface SimulationResult {
      id: string;
      timestamp: string;
      status: 'success' | 'auth_failed' | 'rate_limited' | 'error';
      statusCode?: number;
      responseTime: number;
      model: string;
      tier: string;
      request: {
        method: string;
        url: string;
        headers: Record<string, string>;
        body: any;
      };
      response: {
        status: number;
        headers?: Record<string, string>;
        data: any;
        error?: string;
      };
      reason: string;
    }

    const RequestSimulator: React.FC = () => {
      const { mode } = useTheme();
      const [selectedModel, setSelectedModel] = useState<Model | null>(null);
      const [selectedTier, setSelectedTier] = useState<Tier | null>(null);
      const [queryText, setQueryText] = useState('Hello, how can you help me today?');
      const [maxTokens, setMaxTokens] = useState(100);
      const [numRequests, setNumRequests] = useState(10);
      const [isRunning, setIsRunning] = useState(false);
      const [results, setResults] = useState<SimulationResult[]>([]);
      const [availableTiers, setAvailableTiers] = useState<Tier[]>([]);
      const [tiersLoading, setTiersLoading] = useState(true);

      // Available models from cluster
      const availableModels: Model[] = [
        {
          id: 'vllm-simulator',
          name: 'vLLM Simulator',
          endpoint: 'http://simulator-llm.apps.summit-gpu.octo-emerging.redhataicoe.com',
          description: 'Test model for policy enforcement simulation'
        },
        {
          id: 'qwen3-0-6b-instruct',
          name: 'Qwen3 0.6B Instruct',
          endpoint: 'http://qwen3-llm.apps.summit-gpu.octo-emerging.redhataicoe.com',
          description: 'Qwen3 model with vLLM runtime'
        }
      ];

      // Load tiers dynamically from backend policies
      useEffect(() => {
        const fetchTiers = async () => {
          try {
            setTiersLoading(true);
            // Fetch policies from backend
            const policies = await apiService.getPolicies();
            console.log('Fetched policies:', policies);
            
            // Extract tiers from auth policy allowedGroups
            const tierSet = new Set<string>();
            
            policies.forEach((policy: any) => {
              // Look for auth policies with allowedGroups
              if (policy.type === 'auth' && policy.items) {
                policy.items.forEach((item: any) => {
                  if (item.allowedGroups && Array.isArray(item.allowedGroups)) {
                    item.allowedGroups.forEach((group: string) => {
                      tierSet.add(group);
                    });
                  }
                });
              }
            });
            
            // Convert to tier objects
            const tiersArray: Tier[] = Array.from(tierSet).map(tierId => ({
              id: tierId,
              name: tierId.split('-').map((word: string) => 
                word.charAt(0).toUpperCase() + word.slice(1)
              ).join(' '),
              description: `${tierId} tier from auth policy`,
              apiKey: `${tierId}_key`,
              limits: 'Policy-based limits'
            }));
            
            // Add an invalid tier for testing
            tiersArray.push({
              id: 'invalid',
              name: 'Invalid Key',
              description: 'Invalid API key to test auth failures',
              apiKey: '',
              limits: 'No access'
            });
            
            console.log('Built tiers from policies:', tiersArray);
            setAvailableTiers(tiersArray);
          } catch (error) {
            console.error('Failed to fetch tiers from policies:', error);
            // Fallback to basic tiers if API fails
            setAvailableTiers([
              {
                id: 'free',
                name: 'Free Tier',
                description: 'Default free tier',
                apiKey: 'free_key',
                limits: 'Basic limits'
              },
              {
                id: 'premium',
                name: 'Premium Tier',
                description: 'Default premium tier',
                apiKey: 'premium_key',
                limits: 'Higher limits'
              }
            ]);
          } finally {
            setTiersLoading(false);
          }
        };

        fetchTiers();
      }, []);

      const handleRunSimulation = async () => {
        console.log('Starting simulation...');
        
        if (!selectedModel || !selectedTier) {
          console.error('Please select both a model and a tier');
          return;
        }

        setIsRunning(true);
        
        try {
          // Run simulation for the specified number of requests
          const newResults: any[] = [];
          for (let i = 1; i <= numRequests; i++) {
            try {
              // Make real API call to the backend simulator
              const response = await apiService.simulateRequest({
                model: selectedModel.id,
                messages: [
                  { role: 'user', content: queryText }
                ],
                max_tokens: maxTokens,
                tier: selectedTier.id,
                apiKey: selectedTier.apiKey
              });

              // Process successful response
              newResults.push({
                id: `sim-${Date.now()}-${i}`,
                timestamp: new Date().toISOString(),
                decision: 'accept',
                reason: 'Request completed successfully',
                model: selectedModel.name,
                tier: selectedTier.name,
                responseData: response.data,
                debug: response.debug
              });
              
            } catch (error: any) {
              // Process error response (rate limited, auth failed, etc.)
              console.error(`Request ${i} failed:`, error);
              newResults.push({
                id: `sim-${Date.now()}-${i}`,
                timestamp: new Date().toISOString(),
                decision: 'reject',
                reason: error.message || 'Request failed',
                model: selectedModel.name,
                tier: selectedTier.name,
                error: error
              });
            }
            
            // Small delay between requests to avoid overwhelming the system
            await new Promise(resolve => setTimeout(resolve, 500));
          }
          setResults(prev => [...newResults, ...prev]);
        } catch (error) {
          console.error('Simulation error:', error);
        } finally {
          setIsRunning(false);
          console.log('Simulation completed');
        }
      };

      return (
        <Box>
          <Typography variant="h4" component="h1" gutterBottom>
            Request Simulator
          </Typography>
          
          <Typography variant="body1" color="text.secondary" sx={{ mb: 2 }}>
            Test your policies by simulating requests and seeing how they would be handled by Kuadrant.
          </Typography>

          <Grid container spacing={4} sx={{ mb: 4 }}>
            {/* Left Panel - Model and Tier Selection */}
            <Grid item xs={12} md={8}>
              <Card sx={{ minHeight: 'calc(100vh - 200px)' }}>
                <CardContent sx={{ display: 'flex', flexDirection: 'column' }}>
                  <Typography variant="h6" gutterBottom>
                    Select Model and Tier
                  </Typography>
                  
                  <Grid container spacing={3}>
                    {/* Model Selection */}
                    <Grid item xs={12} sm={6}>
                      <Typography variant="subtitle2" sx={{ mb: 2, fontWeight: 600 }}>
                        Available Models
                      </Typography>
                      <Stack spacing={2}>
                        {availableModels.map((model) => (
                          <Paper
                            key={model.id}
                            onClick={() => setSelectedModel(model)}
                            sx={{
                              p: 2,
                              cursor: 'pointer',
                              background: selectedModel?.id === model.id 
                                ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
                                : 'background.default',
                              color: selectedModel?.id === model.id ? 'white' : 'text.primary',
                              border: selectedModel?.id === model.id ? 'none' : '1px solid',
                              borderColor: 'divider',
                              transition: 'all 0.3s ease',
                              '&:hover': {
                                transform: 'translateY(-2px)',
                                boxShadow: '0 4px 12px rgba(0,0,0,0.15)'
                              }
                            }}
                          >
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                              <ModelIcon />
                              <Box>
                                <Typography variant="body1" fontWeight="600">
                                  {model.name}
                                </Typography>
                                <Typography variant="caption" sx={{ opacity: 0.8 }}>
                                  {model.description}
                                </Typography>
                              </Box>
                            </Box>
                          </Paper>
                        ))}
                      </Stack>
                    </Grid>

                    {/* Tier Selection */}
                    <Grid item xs={12} sm={6}>
                      <Typography variant="subtitle2" sx={{ mb: 2, fontWeight: 600 }}>
                        Available Tiers
                      </Typography>
                      {tiersLoading ? (
                        <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
                          <CircularProgress size={24} />
                          <Typography variant="body2" sx={{ ml: 2, color: 'text.secondary' }}>
                            Loading tiers from policies...
                          </Typography>
                        </Box>
                      ) : (
                        <Box sx={{ flexGrow: 1, overflow: 'auto', maxHeight: '400px' }}>
                          <Stack spacing={2}>
                          {availableTiers.map((tier) => (
                            <Paper
                              key={tier.id}
                              onClick={() => setSelectedTier(tier)}
                              sx={{
                                p: 2,
                                cursor: 'pointer',
                                background: selectedTier?.id === tier.id 
                                  ? tier.id === 'invalid' 
                                    ? 'linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)'
                                    : tier.id === 'test-tokens-blue'
                                    ? 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)'
                                    : tier.id === 'test-tokens-green'
                                    ? 'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)'
                                    : tier.id.startsWith('test-tokens')
                                    ? 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)'
                                    : 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)'
                                  : 'background.default',
                                color: selectedTier?.id === tier.id 
                                  ? tier.id === 'invalid' || tier.id.startsWith('test-tokens') ? 'white' : 'text.primary'
                                  : 'text.primary',
                                border: selectedTier?.id === tier.id ? 'none' : '1px solid',
                                borderColor: 'divider',
                                transition: 'all 0.3s ease',
                                '&:hover': {
                                  transform: 'translateY(-2px)',
                                  boxShadow: '0 4px 12px rgba(0,0,0,0.15)'
                                }
                              }}
                            >
                              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                                <TierIcon />
                                <Box>
                                  <Typography variant="body1" fontWeight="600">
                                    {tier.name}
                                  </Typography>
                                  <Typography variant="caption" sx={{ opacity: 0.8 }}>
                                    {tier.limits}
                                  </Typography>
                                </Box>
                              </Box>
                            </Paper>
                          ))}
                          </Stack>
                        </Box>
                      )}
                    </Grid>
                  </Grid>
                </CardContent>
              </Card>
            </Grid>

            {/* Right Panel - Configuration */}
            <Grid item xs={12} md={4}>
              <Card>
                <CardContent>
                  <Typography variant="h6" gutterBottom>
                    Request Configuration
                  </Typography>
                  
                  <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                    <TextField
                      fullWidth
                      label="Query Text"
                      value={queryText}
                      onChange={(e) => setQueryText(e.target.value)}
                      multiline
                      rows={4}
                      sx={{ 
                        '& .MuiOutlinedInput-root': {
                          bgcolor: mode === 'dark' ? 'grey.900' : 'background.default',
                          color: 'text.primary'
                        },
                        '& .MuiInputLabel-root': {
                          color: 'text.secondary'
                        }
                      }}
                    />
                    
                    <TextField
                      fullWidth
                      label="Max Tokens"
                      type="number"
                      value={maxTokens}
                      onChange={(e) => setMaxTokens(parseInt(e.target.value))}
                      sx={{ 
                        '& .MuiOutlinedInput-root': {
                          bgcolor: mode === 'dark' ? 'grey.900' : 'background.default',
                          color: 'text.primary'
                        },
                        '& .MuiInputLabel-root': {
                          color: 'text.secondary'
                        }
                      }}
                    />

                    <TextField
                      fullWidth
                      label="Number of Requests"
                      type="number"
                      value={numRequests}
                      onChange={(e) => setNumRequests(parseInt(e.target.value))}
                      inputProps={{ min: 1, max: 50 }}
                      sx={{ 
                        '& .MuiOutlinedInput-root': {
                          bgcolor: mode === 'dark' ? 'grey.900' : 'background.default',
                          color: 'text.primary'
                        },
                        '& .MuiInputLabel-root': {
                          color: 'text.secondary'
                        }
                      }}
                    />

                    {selectedModel && selectedTier && (
                      <Alert severity="info">
                        <Typography variant="body2">
                          <strong>Ready:</strong> {selectedModel.name} with {selectedTier.name} tier
                        </Typography>
                      </Alert>
                    )}

                    <Button
                      variant="contained"
                      size="large"
                      fullWidth
                      startIcon={isRunning ? <CircularProgress size={20} color="inherit" /> : <PlayIcon />}
                      onClick={handleRunSimulation}
                      disabled={!selectedModel || !selectedTier || isRunning}
                      sx={{
                        py: 2,
                        fontSize: '1.1rem',
                        fontWeight: 600,
                        background: selectedModel && selectedTier 
                          ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
                          : 'linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%)',
                        '&:hover': {
                          background: selectedModel && selectedTier 
                            ? 'linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%)'
                            : 'linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%)'
                        }
                      }}
                    >
                      {isRunning ? `Running ${numRequests} Requests...` : `Run ${numRequests} Request${numRequests > 1 ? 's' : ''}`}
                    </Button>
                  </Box>
                </CardContent>
              </Card>
            </Grid>
          </Grid>

          {results.length > 0 && (
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  Simulation Results
                </Typography>
                
                <Alert severity="success" sx={{ mb: 2 }}>
                  Simulation completed successfully! Found {results.length} result(s).
                </Alert>
                
                {results.map((result) => (
                  <Box key={result.id} sx={{ mb: 2, p: 2, border: '1px solid #ccc', borderRadius: 1 }}>
                    <Typography variant="body2">
                      <strong>Decision:</strong> {result.decision}<br />
                      <strong>Reason:</strong> {result.reason}<br />
                      <strong>Model:</strong> {result.model}<br />
                      <strong>Tier:</strong> {result.tier}<br />
                      <strong>Time:</strong> {new Date(result.timestamp).toLocaleString()}
                    </Typography>
                  </Box>
                ))}
              </CardContent>
            </Card>
          )}
        </Box>
      );
    };

    export default RequestSimulator;
  PolicyManager.tsx: |
    import React, { useState, useEffect } from 'react';
    import {
      Box,
      Button,
      Chip,
      IconButton,
      TextField,
      Typography,
      Table,
      TableBody,
      TableCell,
      TableContainer,
      TableHead,
      TableRow,
      Paper,
      Tooltip,
      Card,
      CardContent,
      Grid,
    } from '@mui/material';
    import {
      Add as AddIcon,
      Edit as EditIcon,
      Delete as DeleteIcon,
      Search as SearchIcon,
    } from '@mui/icons-material';

    import { Policy } from '../types';
    import apiService from '../services/api';

    const PolicyManager: React.FC = () => {
      const [policies, setPolicies] = useState<Policy[]>([]);
      const [filteredPolicies, setFilteredPolicies] = useState<Policy[]>([]);
      const [searchTerm, setSearchTerm] = useState('');
      const [loading, setLoading] = useState(true);

      useEffect(() => {
        const fetchPolicies = async () => {
          try {
            setLoading(true);
            const data = await apiService.getPolicies();
            setPolicies(data);
            setFilteredPolicies(data);
          } catch (error) {
            console.error('Failed to fetch policies:', error);
          } finally {
            setLoading(false);
          }
        };

        fetchPolicies();
      }, []);

      useEffect(() => {
        const filtered = policies.filter(policy =>
          policy.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
          policy.description.toLowerCase().includes(searchTerm.toLowerCase())
        );
        setFilteredPolicies(filtered);
      }, [searchTerm, policies]);

      if (loading) {
        return (
          <Box display="flex" justifyContent="center" alignItems="center" minHeight="400px">
            <Typography>Loading policies...</Typography>
          </Box>
        );
      }

      return (
        <Box>
          <Box sx={{ mb: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Typography variant="h4" component="h1">
              Policy Management
            </Typography>
            <Button
              variant="contained"
              startIcon={<AddIcon />}
              sx={{ ml: 2 }}
            >
              Create Policy
            </Button>
          </Box>

          <Grid container spacing={3} sx={{ mb: 3 }}>
            <Grid item xs={12} sm={6} md={4}>
              <Card>
                <CardContent>
                  <Typography color="text.secondary" gutterBottom>
                    Total Policies
                  </Typography>
                  <Typography variant="h4" component="div">
                    {policies.length}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
          </Grid>

          <Box sx={{ mb: 3 }}>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="Search policies..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              InputProps={{
                startAdornment: <SearchIcon sx={{ mr: 1, color: 'text.secondary' }} />,
              }}
            />
          </Box>

          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Policy</TableCell>
                  <TableCell>Description</TableCell>
                  <TableCell>Tiers & Models</TableCell>
                  <TableCell>Request Limits</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell align="right">Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {filteredPolicies.map((policy) => (
                  <TableRow key={policy.id} hover>
                    <TableCell>
                      <Typography variant="subtitle2" fontWeight="bold">
                        {policy.name}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Typography variant="body2" color="text.secondary">
                        {policy.description}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                        {policy.items && policy.items.map((item, index) => {
                          if (item.allowedGroups && Array.isArray(item.allowedGroups)) {
                            return item.allowedGroups.map((group, groupIndex) => (
                              <Chip
                                key={`${index}-${groupIndex}`}
                                label={group}
                                size="small"
                                color={
                                  group === 'free' ? 'success' :
                                  group === 'premium' ? 'warning' :
                                  group === 'enterprise' ? 'secondary' :
                                  group.startsWith('test-tokens') ? 'info' : 'default'
                                }
                              />
                            ));
                          }
                          return null;
                        })}
                        {(!policy.items || policy.items.length === 0) && (
                          <Typography variant="body2" color="text.secondary">
                            N/A ({policy.type === 'auth' ? 'Auth only' : 'Rate limit only'})
                          </Typography>
                        )}
                      </Box>
                    </TableCell>
                    <TableCell>
                      {policy.items && policy.items.some(item => item.rates) ? (
                        <Box>
                          {policy.items
                            .filter(item => item.rates && item.rates.length > 0)
                            .map((item, index) => (
                              <Box key={index} sx={{ mb: index > 0 ? 1 : 0 }}>
                                <Typography variant="body2" fontWeight="600">
                                  {item.rates[0].limit} 
                                  {(policy.name.toLowerCase().includes('token') || policy.name.includes('gateway-token-rate-limits')) ? ' tokens' : ' requests'}
                                </Typography>
                                <Typography variant="caption" color="text.secondary">
                                  per {item.rates[0].window} {item.id !== 'default' ? `(${item.id})` : ''}
                                </Typography>
                              </Box>
                            ))}
                        </Box>
                      ) : (
                        <Typography variant="body2" color="text.secondary">
                          {policy.type === 'auth' ? 'N/A (Auth only)' : 'No limits set'}
                        </Typography>
                      )}
                    </TableCell>
                    <TableCell>
                      <Chip
                        label={policy.isActive ? 'Active' : 'Inactive'}
                        color={policy.isActive ? 'success' : 'default'}
                        size="small"
                      />
                    </TableCell>
                    <TableCell align="right">
                      <Tooltip title="Edit Policy">
                        <IconButton size="small">
                          <EditIcon />
                        </IconButton>
                      </Tooltip>
                      <Tooltip title="Delete Policy">
                        <IconButton size="small" color="error">
                          <DeleteIcon />
                        </IconButton>
                      </Tooltip>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>

          {filteredPolicies.length === 0 && (
            <Box
              sx={{
                textAlign: 'center',
                py: 6,
                bgcolor: 'background.paper',
                borderRadius: 1,
                mt: 2,
              }}
            >
              <Typography variant="h6" color="text.secondary" gutterBottom>
                No policies found
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                {searchTerm ? 'Try adjusting your search criteria' : 'Get started by creating your first policy'}
              </Typography>
            </Box>
          )}
        </Box>
      );
    };

    export default PolicyManager;
  MetricsDashboard.tsx: |
    import React, { useState } from 'react';
    import {
      Box,
      Card,
      CardContent,
      Typography,
      Grid,
      CircularProgress,
      Alert,
      IconButton,
      Tooltip,
      FormControl,
      Select,
      MenuItem,
      Chip,
    } from '@mui/material';
    import {
      CheckCircle as AcceptIcon,
      Cancel as RejectIcon,
      Security as PolicyIcon,
      Speed as RateLimitIcon,
      Http as EndpointIcon,
      Refresh as RefreshIcon,
      Pause as PauseIcon,
      PlayArrow as PlayIcon,
    } from '@mui/icons-material';

    import { useDashboardStats } from '../hooks/useApi';

    const MetricsDashboard: React.FC = () => {
      const [autoRefresh, setAutoRefresh] = useState(true);
      const [refreshInterval, setRefreshInterval] = useState(10000);
      
      const { 
        stats, 
        loading: statsLoading, 
        refreshing: statsRefreshing,
        error: statsError, 
        lastUpdated: statsLastUpdated,
        refetch: refetchStats 
      } = useDashboardStats(autoRefresh, 15000);
      
      if (statsLoading) {
        return (
          <Box display="flex" justifyContent="center" alignItems="center" minHeight="400px">
            <CircularProgress />
            <Typography sx={{ ml: 2 }}>Loading live metrics...</Typography>
          </Box>
        );
      }

      if (statsError) {
        return (
          <Alert severity="error" sx={{ mb: 2 }}>
            <Typography variant="h6">Error Loading Metrics</Typography>
            <Typography variant="body2">{statsError}</Typography>
          </Alert>
        );
      }

      // Use real Prometheus metrics from dashboard API for top-level stats
      
      // Direct access instead of destructuring to avoid potential issues
      const totalRequests = stats?.totalRequests || 0;
      const acceptedRequests = stats?.acceptedRequests || 0;
      const rejectedRequests = stats?.rejectedRequests || 0;
      const authFailedRequests = stats?.authFailedRequests || 0;
      const rateLimitedRequests = stats?.rateLimitedRequests || 0;
      const policyEnforcedRequests = stats?.policyEnforcedRequests || 0;
      const kuadrantStatus = stats?.kuadrantStatus || {};
      const authorinoStats = stats?.authorinoStats || null;
      const source = stats?.source || 'unknown';
      

      // Extract real Authorino controller metrics (only what's available from Prometheus)
      const authConfigsManaged = authorinoStats?.authConfigs || 0;
      const authConfigReconciles = authorinoStats?.reconcileOperations || 0;
      
      // No more calculated metrics - only real Prometheus data

      return (
        <Box>
          {/* Header */}
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2, flexWrap: 'wrap', gap: 2 }}>
            <Typography variant="h4" component="h1">
              Live Request Metrics
            </Typography>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, flexWrap: 'wrap' }}>
              {/* Refresh Controls */}
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, p: 1, border: 1, borderColor: 'divider', borderRadius: 1 }}>
                <Tooltip title={autoRefresh ? 'Pause auto-refresh' : 'Resume auto-refresh'}>
                  <IconButton 
                    size="small" 
                    onClick={() => setAutoRefresh(!autoRefresh)}
                    color={autoRefresh ? 'primary' : 'default'}
                  >
                    {autoRefresh ? <PauseIcon /> : <PlayIcon />}
                  </IconButton>
                </Tooltip>
                <FormControl size="small" sx={{ minWidth: 80 }}>
                  <Select
                    value={refreshInterval}
                    onChange={(e) => setRefreshInterval(Number(e.target.value))}
                    disabled={!autoRefresh}
                    variant="outlined"
                  >
                    <MenuItem value={5000}>5s</MenuItem>
                    <MenuItem value={10000}>10s</MenuItem>
                    <MenuItem value={30000}>30s</MenuItem>
                    <MenuItem value={60000}>1m</MenuItem>
                  </Select>
                </FormControl>
                <Tooltip title="Manual refresh">
                  <IconButton 
                    size="small" 
                    onClick={() => {
                      refetchStats();
                    }}
                    disabled={statsRefreshing}
                  >
                    <RefreshIcon sx={{ 
                      animation: statsRefreshing ? 'spin 1s linear infinite' : 'none',
                      '@keyframes spin': {
                        '0%': { transform: 'rotate(0deg)' },
                        '100%': { transform: 'rotate(360deg)' }
                      }
                    }} />
                  </IconButton>
                </Tooltip>
              </Box>

              {/* Status Indicators */}
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                <Typography variant="body2" color="text.secondary">
                  Data Source:
                </Typography>
                <Chip 
                  label={source === 'prometheus-metrics' ? 'Prometheus' : 'Fallback'}
                  color={source === 'prometheus-metrics' ? 'success' : 'warning'} 
                  size="small"
                />
              </Box>
            </Box>
          </Box>
          
          {/* First Row - Basic Stats */}
          <Grid container spacing={3} sx={{ mb: 3 }}>
            <Grid item xs={12} sm={6} md={3}>
              <Card>
                <CardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                    <EndpointIcon sx={{ mr: 1 }} />
                    <Typography color="text.secondary" gutterBottom>
                      Total Requests
                    </Typography>
                  </Box>
                  <Typography variant="h4" component="div">
                    {totalRequests}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <Card>
                <CardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                    <AcceptIcon sx={{ mr: 1, color: 'success.main' }} />
                    <Typography color="text.secondary" gutterBottom>
                      Requests Approved
                    </Typography>
                  </Box>
                  <Typography variant="h4" component="div" color="success.main">
                    {acceptedRequests}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {totalRequests > 0 ? `${((acceptedRequests / totalRequests) * 100).toFixed(1)}%` : '0%'}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <Card>
                <CardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                    <RejectIcon sx={{ mr: 1, color: 'error.main' }} />
                    <Typography color="text.secondary" gutterBottom>
                      Requests Rejected
                    </Typography>
                  </Box>
                  <Typography variant="h4" component="div" color="error.main">
                    {rejectedRequests}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {totalRequests > 0 ? `${((rejectedRequests / totalRequests) * 100).toFixed(1)}%` : '0%'}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <Card>
                <CardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                    <AcceptIcon sx={{ mr: 1, color: 'success.main' }} />
                    <Typography color="text.secondary" gutterBottom>
                      Success Rate
                    </Typography>
                  </Box>
                  <Typography variant="h4" component="div" color="success.main">
                    {totalRequests > 0 ? `${((acceptedRequests / totalRequests) * 100).toFixed(1)}%` : 'N/A'}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Requests approved
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
          </Grid>

          {/* Second Row - Policy Breakdown */}
          <Grid container spacing={3} sx={{ mb: 4 }}>
            <Grid item xs={12} sm={6} md={3}>
              <Card>
                <CardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                    <PolicyIcon sx={{ mr: 1 }} />
                    <Typography color="text.secondary" gutterBottom>
                      Authentication
                    </Typography>
                  </Box>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 3 }}>
                    <Box sx={{ textAlign: 'center' }}>
                      <Typography variant="h5" component="div" color="error.main">
                        {authFailedRequests}
                      </Typography>
                      <Typography variant="body2" color="error.main">
                        Blocked
                      </Typography>
                    </Box>
                    <Box sx={{ textAlign: 'center' }}>
                      <Typography variant="h5" component="div" color="success.main">
                        {totalRequests - authFailedRequests}
                      </Typography>
                      <Typography variant="body2" color="success.main">
                        Passed
                      </Typography>
                    </Box>
                  </Box>
                  <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                    Auth success: {totalRequests > 0 ? `${(((totalRequests - authFailedRequests) / totalRequests) * 100).toFixed(1)}%` : '0%'}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <Card>
                <CardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                    <RateLimitIcon sx={{ mr: 1 }} />
                    <Typography color="text.secondary" gutterBottom>
                      Rate Limiting
                    </Typography>
                  </Box>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 3 }}>
                    <Box sx={{ textAlign: 'center' }}>
                      <Typography variant="h5" component="div" color="error.main">
                        {rateLimitedRequests}
                      </Typography>
                      <Typography variant="body2" color="error.main">
                        Blocked
                      </Typography>
                    </Box>
                    <Box sx={{ textAlign: 'center' }}>
                      <Typography variant="h5" component="div" color="success.main">
                        {(totalRequests - authFailedRequests) - rateLimitedRequests}
                      </Typography>
                      <Typography variant="body2" color="success.main">
                        Passed
                      </Typography>
                    </Box>
                  </Box>
                  <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                    Rate success: {(totalRequests - authFailedRequests) > 0 ? `${((((totalRequests - authFailedRequests) - rateLimitedRequests) / (totalRequests - authFailedRequests)) * 100).toFixed(1)}%` : '0%'}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            {/* Empty spaces for consistent layout */}
            <Grid item xs={12} sm={6} md={3}></Grid>
            <Grid item xs={12} sm={6} md={3}></Grid>
          </Grid>

        </Box>
      );
    };

    export default MetricsDashboard;
  types.ts: |
    export interface Policy {
      id: string;
      name: string;
      description: string;
      type: 'auth' | 'rateLimit';
      isActive: boolean;
      timeRange: {
        unlimited: boolean;
        startTime?: string;
        endTime?: string;
      };
      items: PolicyItem[];
      requestLimits?: {
        tokenLimit: number | null;
        timePeriod: string;
      };
    }

    export interface PolicyItem {
      id: string;
      type: 'tier' | 'model';
      value: string;
    }

    export interface Request {
      id: string;
      timestamp: string;
      team: string;
      model: string;
      endpoint?: string;
      decision: string;
      policyType?: string;
    }

    export interface Team {
      id: string;
      name: string;
      tier: string;
    }

    export interface Model {
      id: string;
      name: string;
      description: string;
      isActive: boolean;
    }